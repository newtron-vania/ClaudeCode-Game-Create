# **유니티 개발 표준 가이드 문서**

*이 문서는 유니티 프로젝트에서 코드의 일관성을 유지하고 협업의 효율성을 높이기 위해 작성되었습니다.*  
*코드 가독성과 유지보수성을 고려한 개발 표준을 정립하고, 팀원 간의 원활한 협업을 지원하는 것을 목표로 합니다.*

## ***사용 목적***

* *코드 스타일과 네이밍 규칙을 미리 정하여 **일관된 개발 환경**을 구축할 때*  
* ***팀 내 코드 작성 규칙을 통일**하여 여러 개발자가 협업하는 프로젝트에서 코드 품질과 가독성을 유지해야 할 때*  
* ***코드 리뷰**를 통해 일관된 기준을 바탕으로 코드 품질을 점검하고 개선할 때*  
* ***유지보수 및 리팩토링** 작업 시 기존 코드의 가독성을 높이고, 표준에 맞게 수정해야 할 때*  
* ***유니티 개발 방식이 익숙하지 않은 팀원이 있을 때** 문서를 참고하여 빠르게 적응할 수 있도록 할 때*

## ***가이드 목차***

***1\. 네이밍 규칙***  
*1.1. 변수 네이밍 규칙*  
*1.2. 클래스와 구조체 네이밍 규칙*  
*1.3. 메서드와 함수 네이밍 규칙*  
*1.4. Bool 변수와 메서드의 네이밍 규칙*  
*1.5. 네임스페이스 (Namespaces)*  
*1.6. 약어 사용 규칙*  
***2\. 코드 컨벤션 및 클래스 구조***  
*2.1. 코드 포맷팅*  
*2.2. 접근 제어자와 Unity 객체 참조*  
*2.3. Partial 클래스 사용 규칙*  
*2.4. Static 클래스와 싱글톤 패턴 사용 규칙*  
*2.5. Extension 메서드 작성 규칙*  
***3\. 흐름 제어 및 예외 처리***  
*3.1. switch 문 사용 규칙 및 포맷팅*  
*3.2. 재귀 함수 사용 규칙과 대체 방법*  
*3.3. Assert와 Log, Error Detection 사용 규칙*  
***4\. C\# 타입 관리***  
*4.1. var 사용 규칙*  
*4.2. dynamic과 object 사용 규칙*  
*4.3. null 사용 규칙과 예외 처리*  
***5\. 디렉토리 및 파일 관리***  
*5.1. 디렉토리 구조 설계 및 네이밍 규칙*  
***6\. 주석 작성 규칙***

# ***GUIDE RULE***

## **1\. 네이밍 규칙**

### 1.1. 변수 네이밍 규칙

#### **프라이빗 변수**

* 접두사로 \_(underscore) \+ camelCase를 사용합니다.

| `private int _variable; private int _variableCount;` |
| :---- |

#### **퍼블릭 변수**

* PascalCase로 작성합니다.  
* 퍼블릭 변수를 직접 사용하는 것보다는 프로퍼티를 사용하는 것을 권장합니다.

| `public int Variable; public int VariableCount;` |
| :---- |

#### **프로퍼티와 백킹 필드**

* 백킹 필드는 일반적인 프라이빗 변수처럼 \_ \+ camelCase로 작성합니다.  
* 프로퍼티는 PascalCase로 작성합니다.

| `private int _variableProperty; public int VariableProperty {     get { return _variableProperty; }     set { _variableProperty = value; } }` |
| :---- |

#### **지역 변수와 매개변수**

* \_없이 camelCase로만 작성합니다.

| `public void ProcessData() {     int processedCount = 0;     for (int i = 0; i < 10; i++)     {         processedCount += i;     } } public void SetName(string userName) {     _name = userName; }` |
| :---- |

#### **상수**

* 대문자 \+ \_언더스코어를 사용합니다.

| `public const int MAX_HEALTH = 100;` |
| :---- |

#### **Readonly 필드**

* 접근 제어자에 맞춰 명명하고 생성자에서 초기화합니다.

| `private readonly int _initialHealth; public readonly int InitialHealth; public Player(int health) {     _initialHealth = health;     InitialHealth = health; }` |
| :---- |

### 1.2. 클래스와 구조체 네이밍 규칙

#### **클래스**

* PascalCase를 사용하고 명사로 표현합니다.  
* 스크립트 파일과 클래스의 이름은 동일해야 합니다.

| *`// PlayerController.cs`* `public class PlayerController : MonoBehaviour { }` |
| :---- |

#### **구조체**

* PascalCase를 사용하고 데이터 컨테이너임을 드러내도록 명명합니다.

| `public struct PlayerStats { }` |
| :---- |

#### **인터페이스**

* I \+ PascalCase로 작성합니다.

| `public interface IDamageable {     void TakeDamage(int damage); }` |
| :---- |

#### **열거형 클래스**

* PascalCase를 사용하고 각 값은 PascalCase로 작성합니다.

| `public enum EnemyType {     Melee,     Ranged,     Boss }` |
| :---- |

#### **비트 플래그 열거형 클래스**

* PascalCase를 사용하고 이름 뒤에 Flags를 붙입니다.  
* \[Flags\] 특성을 사용하고 값은 2의 거듭제곱으로 할당합니다.

| `[Flags] public enum ItemAttributesFlags {     None = 0,     Flammable = 1 << 0,     Edible = 1 << 1,     Fragile = 1 << 2,     Heavy = 1 << 3,     Valuable = 1 << 4 }` |
| :---- |

### 1.3. 메서드와 함수 네이밍 규칙

#### **일반적인 경우**

* PascalCase를 사용하고 동사로 시작하며 명확한 동작을 표현합니다.

| `public void MovePlayer(Vector3 direction) { } private void HandleInput() { }` |
| :---- |

#### **Unity 이벤트 메서드**

* Unity에서 제공하는 콜백 메서드는 정확한 이름을 사용합니다.

| `private void Start() {} private void Update() {} private void OnCollisionEnter(Collision other) { }` |
| :---- |

#### **코루틴 메서드**

* PascalCase를 사용하고 "DoSomethingCoroutine" 같은 이름을 사용해 코루틴임을 명확히 명명합니다.

| `private IEnumerator MovePlayerCoroutine(Vector3 destination) {     while (Vector3.Distance(transform.position, destination) > 0.1f)     {         transform.position = Vector3.MoveTowards(transform.position, destination, _moveSpeed * Time.deltaTime);         yield return null;     } }` |
| :---- |

#### **이벤트**

* PascalCase로 작성하고 "OnSomethingHappened" 형식으로 명명합니다.

| `public event Action OnPlayerDeath; private void Die() {     OnPlayerDeath?.Invoke(); }` |
| :---- |

### 1.4. Bool 변수와 메서드의 네이밍 규칙

* {\_}? \+ 접두사 \+ {camelCase or PascalCase} 형식을 사용합니다.  
* 부정적인 이름은 피합니다.

| `private bool _isGrounded; private bool _hasKey; public bool IsGrounded => _isGrounded; public bool HasKey => _hasKey; bool isActive = !isPaused;  // 부정적인 표현 대신 긍정적인 변수명 사용`  |
| :---- |

### 1.5. 네임스페이스

* PascalCase로 작성하고 프로젝트의 구조를 반영해야 합니다.

| `namespace MyGame.Player {     public class PlayerController { } }` |
| :---- |

### 1.6. 약어 사용 규칙

* 약어는 PascalCase 또는 camelCase에 따라 섞지 않습니다.  
* 짧고 명확한 약어만 허용합니다.  
* 전역 변수에서는 약어 사용을 지양합니다.  
* 클래스 변수에서는 자료구조나 특정 역할을 강조하기 위해 허용됩니다.  
* 메서드 내 지역 변수는 컨텍스트에 따라 유연하게 약어 사용이 가능합니다.

| `public static class UI {     public static GameManager Instance { get; private set; } }` |
| :---- |

| `public class GameDataManager {     private Dictionary<string, int> _itemDict;     private Database _playerDB;     private int _scoreSum; }` |
| :---- |

| `public void Move(Vector3 dir, float spd) {     Vector3 newPos = transform.position + dir * spd * Time.deltaTime;     transform.position = newPos; }`  |
| :---- |

## **2\. 코드 컨벤션 및 클래스 구조**

### 2.1. 코드 포맷팅

* 중괄호{}는 같은 줄에 배치합니다.  
* 코드 블록 사이에는 한 줄 공백을 넣어 가독성을 높입니다.

| `public void Jump() {     if (_isGrounded)     {         _rigidbody.AddForce(Vector3.up * jumpForce);     } }` |
| :---- |

### 2.2. 접근 제어자와 Unity 객체 참조

* 접근 제어자는 항상 명시적으로 작성하고 기본적으로 private으로 설정합니다.  
* Unity 객체 참조는 \[SerializeField\]로 인스펙터에서 설정합니다.

| `public class Enemy : MonoBehaviour {     [SerializeField] private float _speed;     [SerializeField] private int _damage;     public void Attack() { } }` |
| :---- |

### 2.3. Partial 클래스 사용 규칙

* 큰 클래스를 여러 파일에 분할하여 관리할 때 사용합니다.  
* 자동 생성 코드와 사용자 정의 코드를 분리할 때 유용합니다.

| *`// PlayerInfo.cs`* `public partial class Player : IPlayer {     public string Name { get; set; }     public int Health { get; set; } } // PlayerActions.cs public partial class Player {     public void Move()     {         Debug.Log($"{Name} is moving.");     }     public void Attack()     {         Debug.Log($"{Name} is attacking.");     } }` |
| :---- |

### 2.4. Static 클래스와 싱글톤 패턴 사용 규칙

#### **Static 클래스**

* 유틸리티 기능처럼 상태를 가지지 않는 경우 사용합니다.

| `public static class MathUtilities {     public static float Clamp(float value, float min, float max)     {         return Mathf.Max(min, Mathf.Min(max, value));     } }` |
| :---- |

#### **싱글톤 패턴**

* 전역적으로 하나의 인스턴스만 필요하고, 상태를 유지해야 할 때 사용합니다.

| `public class GameManager : MonoBehaviour {     private static GameManager _instance;     public static GameManager Instance     {         get         {             if (_instance == null)             {                 _instance = FindObjectOfType<GameManager>();                 if (_instance == null)                 {                     GameObject obj = new GameObject(nameof(GameManager));                     _instance = obj.AddComponent<GameManager>();                 }             }             return _instance;         }     }     private void Awake()     {         if (_instance == null)         {             _instance = this;             DontDestroyOnLoad(gameObject);         }         else         {             Destroy(gameObject);         }     } }` |
| :---- |

### 2.5. Extension 메서드 작성 규칙

* 정적 클래스 내부에 작성하고 첫 번째 매개변수 앞에 this 키워드를 붙입니다.

| `public static class StringExtensions {     public static bool IsNullOrEmpty(this string value)     {         return string.IsNullOrEmpty(value);     } }` |
| :---- |

## **3\. 흐름 제어 및 예외 처리**

### 3.1. switch 문 사용 규칙 및 포맷팅

* break를 필수적으로 사용하고 default 블록 사용을 권장합니다.  
* 여러 값을 하나의 case에서 처리할 수 있습니다.  
* 중첩 switch문은 지양합니다.

| `switch (command) {     case "Start":         Debug.Log("Game started.");         break;     case "Pause":         Debug.Log("Game paused.");         break;     default:         Debug.Log("Invalid command.");         break; }` |
| :---- |

### 3.2. 재귀 함수 사용 규칙과 대체 방법

* 기저 조건을 명확하게 정의하고 재귀 깊이를 제한합니다.  
* 재귀가 깊거나 반복문으로 대체 가능하다면 반복문을 사용합니다.

| `public int Factorial(int n) {     if (n <= 1)         return 1;     return n * Factorial(n - 1); } public int FactorialIterative(int n) {     int result = 1;     for (int i = 1; i <= n; i++)     {         result *= i;     }     return result; }` |
| :---- |

### 3.3. Assert와 Log, Error Detection 사용 규칙

#### **Assert**

* 중요한 로직에서만 사용하고 필수 로직의 대체로 사용하지 않습니다.

| `Debug.Assert(Health > 0, "Health must be greater than zero.");` |
| :---- |

#### **Log**

* 로그 수준에 따라 적절한 메서드를 사용합니다.  
* 로그 메시지는 구조화된 형식을 따릅니다.

| `Debug.Log("[INFO] PlayerController::Start() - Player initialized with health: 100"); Debug.LogWarning("[WARNING] PlayerHealth::TakeDamage() - Health is below 20"); Debug.LogError("[ERROR] NetworkManager::Connect() - Failed to connect. ErrorCode: 404");` |
| :---- |

#### **Error Detection**

* try-catch 블록을 사용해 예외를 처리합니다.  
* 특정 조건을 감지해 오류를 처리합니다.

| `public void LoadData(string path) {     try     {         string data = File.ReadAllText(path);         Debug.Log("Data loaded successfully.");     }     catch (FileNotFoundException e)     {         Debug.LogError($"File not found: {e.Message}");     }     catch (Exception e)     {         Debug.LogError($"An unexpected error occurred: {e.Message}");     } }` |
| :---- |

## **4\. C\# 타입 관리**

### 4.1. var 사용 규칙

* 지역 변수: var 키워드를 사용하여 타입 추론을 활용합니다.  
* 반복문: var 키워드를 사용하여 컬렉션의 요소 타입을 명시적으로 선언하지 않아도 됩니다.  
* LINQ: LINQ 쿼리 결과에 var 키워드를 사용하여 간결하게 코드를 작성합니다.  
* 주의사항:  
  * 반환 타입이 명확하지 않은 경우 (예: object 타입 반환) var 사용을 지양합니다.  
  * 초기화 없이는 var를 사용할 수 없습니다.

| `public class Example {     public void ProcessData()     {         // 지역 변수         var message = "Hello, World!"; // string으로 추론         Debug.Log(message);         // 반복문         var numbers = new int[] { 1, 2, 3, 4, 5 };         foreach (var num in numbers) // int로 추론         {             Debug.Log(num);         }         // LINQ         var evenNumbers = numbers.Where(n => n % 2 == 0);         foreach (var evenNum in evenNumbers)         {             Debug.Log(evenNum);         }     }     public object GetData()     {         return "Data";     }     public void ExampleMethod()     {         // var data = GetData(); // 반환 타입이 object이므로 지양         object data = GetData(); // 명시적인 타입 사용     } }` |
| :---- |

### 4.2. dynamic과 object 사용 규칙

* dynamic: 런타임에 타입이 결정되므로 컴파일 시 타입 검사를 건너뜁니다.  
  * 외부 라이브러리, COM interop 등 런타임에 타입 정보가 필요한 경우 사용합니다.  
  * 리플렉션 사용을 최소화할 수 있습니다.  
  * 주의사항:  
    * 타입 안정성이 떨어지므로 가능한 한 사용을 피합니다.  
    * 오타 또는 잘못된 메서드 호출 시 런타임 에러가 발생할 수 있습니다.  
* object: 모든 타입의 객체를 담을 수 있는 최상위 타입입니다.  
  * 박싱/언박싱으로 인한 성능 저하가 발생할 수 있습니다.  
  * 주의사항:  
    * 타입 안정성을 보장할 수 없으므로 타입 캐스팅이 필요합니다.  
    * 불필요한 object 사용은 성능 저하를 초래할 수 있습니다.

| `public class Example {     public void UseDynamic()     {         dynamic api = GetExternalAPI();         Debug.Log(api.SomeMethod()); // 런타임에 메서드 호출 성공 여부 결정     }     public void UseObject()     {         object data = GetData();         if (data is string)         {             string message = (string)data;             Debug.Log(message);         }     }     private dynamic GetExternalAPI()     {         // 외부 API 반환 (예시)         return new ExternalAPI();     }     private object GetData()     {         return "Hello, World!";     } } public class ExternalAPI {     public string SomeMethod()     {         return "External API Method";     } }` |
| :---- |

### 4.3. null 사용 규칙과 예외 처리

* null 검사: 객체 사용 전에 null 검사를 수행하여 NullReferenceException을 방지합니다.  
  * ?. (null-conditional operator)와 ?? (null-coalescing operator)를 활용합니다.  
* 초기화: 객체를 선언할 때 null로 초기화하는 것을 고려합니다.  
* 예외 처리: null 관련 예외를 처리하여 안정성을 높입니다.  
* 주의사항:  
  * 불필요한 null 검사는 코드 가독성을 해칠 수 있습니다.  
  * null 반환을 최소화하고, 가능한 경우 빈 컬렉션이나 기본값을 반환합니다.

| `public class Example {     private string _name;     public void ProcessName()     {         // Null-conditional operator         string message = _name?.ToUpper(); // _name이 null이면 message는 null          // Null-coalescing operator         string displayName = _name ?? "Guest"; // _name이 null이면 "Guest" 사용          Debug.Log(displayName);     }     public void Initialize()     {         _name = null; // null로 초기화     }     public void ExampleMethod()     {         try         {             // NullReferenceException 발생 가능성 있는 코드             Debug.Log(_name.Length);         }         catch (NullReferenceException e)         {             Debug.LogError($"NullReferenceException: {e.Message}");         }     } }`  |
| :---- |

## **5\. 디렉토리 및 파일 관리**

### 5.1. 디렉토리 구조 설계 및 네이밍 규칙

*Assets/*  
*│*  
*├── Scripts/           \# 스크립트 관련 파일들*  
*│   ├── Managers/      \# 게임 매니저 스크립트*  
*│   ├── UI/            \# UI 관련 스크립트*  
*│   └── Player/        \# 플레이어 제어 스크립트*  
*│*  
*├── Resources/         \# 런타임 로딩을 위한 리소스*  
*│   ├── UI\_Assets/     \# UI 에셋*  
*│   └── Prefabs/       \# 프리팹 파일*  
*│*  
*├── Audio/             \# 오디오 파일 (BGM, 효과음 등)*  
*│   ├── BGM/           \# 배경음악*  
*│   └── SFX/           \# 효과음*  
*│*  
*└── Art/               \# 아트 에셋 (모델, 텍스처 등)*  
    *├── Models/        \# 3D 모델 파일*  
    *└── Textures/      \# 텍스처 파일*

## 

## **6\. 주석 작성 규칙**

* XML 주석: public 멤버에 대한 설명을 제공합니다.  
  * \<summary\>, \<param\>, \<returns\> 태그를 사용하여 명확하게 설명합니다.  
* 코드 주석: 복잡한 로직이나 중요한 부분을 설명합니다.  
  * 주석은 간결하고 명확하게 작성합니다.  
  * 불필요한 주석은 제거합니다.  
* TODO 주석: 나중에 처리해야 할 작업을 표시합니다.  
  * // TODO: {할 일} 형식으로 작성합니다.

| *`/// <summary>`* `/// 플레이어의 이동을 처리하는 메서드입니다. /// </summary> /// <param name="direction">이동 방향</param> public void MovePlayer(Vector3 direction) {     // 현재 속도에 방향을 곱하여 새로운 위치 계산     Vector3 newPosition = transform.position + direction * _speed * Time.deltaTime;     transform.position = newPosition; }` |
| :---- |

| `// TODO: 애니메이션 추가` |
| :---- |

